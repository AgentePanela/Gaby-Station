using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Numerics;
using Content.Client.Stylesheets;
using Content.Client.UserInterface.Controls;
using Content.Shared.Ame.Components;
using Content.Shared.Canvas;
using Content.Shared.Crayon;
using Content.Shared.Decals;
using Robust.Client.AutoGenerated;
using Robust.Client.GameObjects;
using Robust.Client.Graphics;
using Robust.Client.UserInterface;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Prototypes;
using Robust.Shared.Utility;
using static Content.Shared.Canvas.SharedCanvasComponent;
using static Robust.Client.UserInterface.Controls.BoxContainer;

namespace Content.Client.Canvas.Ui
{
    [GenerateTypedNameReferences]
    public sealed partial class CanvasWindow : FancyWindow
    {
        [Dependency] private readonly IEntityManager _entManager = default!;
        [Dependency] private readonly IPrototypeManager _prototypeManager = default!;
        private readonly SpriteSystem _spriteSystem;

        private NetEntity? _trackedEntity;
        private Texture? _blipTexture;

        private EntityUid? _owner = null;
        private CanvasUiKey _currentUiKey;

        private const int ButtonGridSize = 3;
        private int _height = 16;
        private int _width = 16;

        private string _paintingCode = string.Empty;

        private string _artist = string.Empty;

        private string? _autoSelected;
        private string? _selected;
        private Color _color = Color.Black;

        private const int ButtonSize = 30; // Size of each button (width and height)

        public event Action<Color>? OnColorSelected;
        public event Action<string>? OnSelected;
        public event Action<string>? OnFinalize;


        public CanvasWindow()
        {
            RobustXamlLoader.Load(this);
            IoCManager.InjectDependencies(this);

            _spriteSystem = _entManager.System<SpriteSystem>();
            Search.OnTextChanged += SearchChanged;
            //ColorSelector.OnColorChanged += SelectColor;
            ImportButton.OnPressed += _ =>
            {
                string inputCode = Search.Text.Trim();

                // Ensure the input code is not empty
                if (!string.IsNullOrEmpty(inputCode))
                {
                    // If the input code is shorter than expected, fill the rest with 'W'
                    if (inputCode.Length < _height * _width)
                    {
                        inputCode = inputCode.PadRight(_height * _width, 'W');
                    }

                    // Update the painting code
                    _paintingCode = inputCode;

                    // Populate the grid with the new painting code
                    PopulatePaintingGrid();
                }
                else
                {
                    // Optionally, show an error message
                    Search.Text = "Invalid Code";
                }
            };

            ExportButton.OnPressed += _ =>
            {
                Search.Text = _paintingCode;
                FixPaintingCode();
                PopulatePaintingGrid();
            };

            FinalizeButton.OnPressed += _ =>
            {
                _artist = "Nome do artista";
                OnFinalize?.Invoke(_artist);
            };
            //FixPaintingCode();
            //PopulatePaintingGrid();
        }

        private void SelectColor(Color color)
        {
            _color = color;

            OnColorSelected?.Invoke(color);
            //RefreshList();
        }

        private void SearchChanged(LineEdit.LineEditEventArgs obj)
        {
            //_autoSelected = ""; // Placeholder to kick off the auto-select in refreshlist()
            //RefreshList();
        }

        public void UpdateState(BoundUserInterfaceState state)
        {
            var castState = (CanvasBoundUserInterfaceState)state;
            _selected = castState.Selected;
            ColorSelector.Visible = castState.SelectableColor;
            _color = castState.Color;
            _paintingCode = castState.PaintingCode;
            _height = castState.Height;
            _width = castState.Width;
            _artist = castState.Artist;
            Logger.ErrorS("canvas", $"received update {_paintingCode}.");

            PopulatePaintingGrid();
        }
        public void AdvanceState(string drawn)
        {
            //var filter = Search.Text;
            //if (!filter.Contains(',') || !filter.Contains(drawn))
            //    return;

            //var first = filter[..filter.IndexOf(',')].Trim();

            //if (first.Equals(drawn, StringComparison.InvariantCultureIgnoreCase))
            //{
            //    Search.Text = filter[(filter.IndexOf(',') + 1)..].Trim();
            //    _autoSelected = first;
            //}

            //RefreshList();
        }

        private void HandleColorSelected(Color color)
        {
            _color = color; // Update the current selected color
            ColorPreview.ModulateSelfOverride = color;
            OnColorSelected?.Invoke(color); // Trigger the event for external handlers
        }

        public void PopulateColorSelector(List<Color> colors)
        {
            // Clear existing children in ColorSelector
            ColorSelector.RemoveAllChildren();

            foreach (var color in colors)
            {
                // Create a button for each color
                var colorButton = new Button
                {
                    MinSize = new Vector2(ButtonSize, ButtonSize),
                    MaxSize = new Vector2(ButtonSize, ButtonSize),
                    ModulateSelfOverride = color, // Set the button background to the color
                };

                // Attach an event to handle color selection
                colorButton.OnPressed += _ => HandleColorSelected(color);

                // Add the button to the ColorSelector
                ColorSelector.AddChild(colorButton);
            }
        }

        public void SetPaintingCode(string code)
        {
            _paintingCode = code;
        }
        public void SetArtist(string artist)
        {
            _artist = artist;
        }
        public void PopulatePaintingGrid()
        {
            // Clear any existing children in the Grids container
            Grids.RemoveAllChildren();

            int index = 0; // Index to track the position in the painting code

            // Iterate over rows
            for (int row = 0; row < _height; row++)
            {
                int currentRow = row;
                // Create a new horizontal BoxContainer for each row
                var rowContainer = new BoxContainer
                {
                    Orientation = BoxContainer.LayoutOrientation.Horizontal,
                    HorizontalExpand = true,
                    VerticalExpand = false,
                    Align = AlignMode.Center
                };

                // Iterate over columns for the current row
                for (int col = 0; col < _width; col++)
                {
                    // Create local copies of row and col to capture their values correctly
                    int currentCol = col;

                    // Get the initial color for this cell, defaulting to white if index out of bounds
                    Color initialColor = index < _paintingCode.Length
                        ? GetColorFromCode(_paintingCode[index])
                        : Color.White;

                    index++; // Increment the index

                    // Create a new button
                    var button = new Button
                    {
                        MinSize = new Vector2(ButtonSize, ButtonSize),
                        MaxSize = new Vector2(ButtonSize, ButtonSize),
                        StyleClasses = { "squareButton" }, // Optional: Add a style class for custom styling
                        ModulateSelfOverride = initialColor // Set the background color
                    };

                    // Add event to change color on click
                    if (string.IsNullOrEmpty(_artist))
                    {
                        button.OnPressed += _ =>
                        {
                            button.ModulateSelfOverride = _color;
                            UpdatePaintingCode(currentRow, currentCol, _color); // Use the local variables
                        };
                    }

                    // Add the button to the current row container
                    rowContainer.AddChild(button);
                }

                // Add the row container to the Grids container
                Grids.AddChild(rowContainer);
            }
            if (!string.IsNullOrEmpty(_artist))
            {
                var button = new Button
                {
                    Text = _artist, // Optional: Add a style class for custom styling
                    ModulateSelfOverride = Color.Black // Set the background color
                };
                Grids.AddChild(button);
            }
        }

        /// <summary>
        /// Updates the painting code when a button's color changes.
        /// </summary>
        private void UpdatePaintingCode(int row, int col, Color color)
        {
            if (!string.IsNullOrEmpty(_artist))
                return;
            Logger.ErrorS("canvas", $"pitando {row} {col}");

            // Ensure _paintingCode is properly initialized
            FixPaintingCode();

            // Calculate the index in the painting code string
            int index = row * _width + col;  // Correct formula

            // Safety check to ensure the index is within bounds
            if (index < 0 || index >= _paintingCode.Length)
            {
                // Log or handle the error gracefully
                Logger.ErrorS("canvas", $"Index {index} {row} {col} is out of bounds for painting code.");
                return;
            }

            // Get the character representing the color
            char colorCode = GetCodeFromColor(color);

            // Replace the character at the index
            char[] codeArray = _paintingCode.ToCharArray();
            codeArray[index] = colorCode;
            _paintingCode = new string(codeArray);
            OnSelected?.Invoke(_paintingCode);
        }
        /// <summary>
        /// Converts a color code character to a Color object.
        /// </summary>
        private Color GetColorFromCode(char code)
        {
            return code switch
            {
                'R' => Color.Red,
                'G' => Color.Green,
                'B' => Color.Blue,
                'Y' => Color.Yellow,
                'C' => Color.Cyan,
                'M' => Color.Magenta,
                'O' => new Color(1.0f, 0.65f, 0.0f), // Orange
                'P' => new Color(0.75f, 0.0f, 0.75f), // Purple
                'T' => new Color(0.33f, 0.55f, 0.2f), // Teal
                'L' => Color.LightGray,
                'D' => Color.DarkGray,
                'K' => Color.Black,
                _ => Color.White, // Default to white
            };
        }

        /// <summary>
        /// Converts a Color object to a color code character.
        /// </summary>
        private char GetCodeFromColor(Color color)
        {
            if (color == Color.Red) return 'R';
            if (color == Color.Green) return 'G';
            if (color == Color.Blue) return 'B';
            if (color == Color.Yellow) return 'Y';
            if (color == Color.Cyan) return 'C';
            if (color == Color.Magenta) return 'M';
            if (color == new Color(1.0f, 0.65f, 0.0f)) return 'O'; // Orange
            if (color == new Color(0.75f, 0.0f, 0.75f)) return 'P'; // Purple
            if (color == new Color(0.33f, 0.55f, 0.2f)) return 'T'; // Teal
            if (color == Color.LightGray) return 'L';
            if (color == Color.DarkGray) return 'D';
            if (color == Color.Black) return 'K';
            return 'W'; // Default to white
        }

        public void InitializeFromYaml(string paintingCode)
        {
            if (!string.IsNullOrEmpty(paintingCode))
            {
                _paintingCode = paintingCode;
            }

            //PopulatePaintingGrid();
        }
        private void FixPaintingCode()
        {
            int requiredLength = _height * _width;

            if (string.IsNullOrEmpty(_paintingCode))
            {
                // Initialize with default 'W' if _paintingCode is null or empty
                _paintingCode = new string('W', requiredLength);
            }
            else
            {
                // Adjust the length of _paintingCode
                _paintingCode = _paintingCode.Length < requiredLength
                    ? _paintingCode.PadRight(requiredLength, 'W') // Pad with 'W'
                    : _paintingCode.Substring(0, requiredLength); // Trim excess
            }
        }

    }
}
